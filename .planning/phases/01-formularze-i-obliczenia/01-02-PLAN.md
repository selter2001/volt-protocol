---
phase: 01-formularze-i-obliczenia
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Po wpisaniu Zs i wyborze zabezpieczenia B16 wartosci Id i Zsmax obliczaja sie automatycznie"
    - "Ocena POZYTYWNA/NEGATYWNA pojawia sie natychmiast po obliczeniu"
    - "Uzytkownik moze wybrac zabezpieczenie z listy rozwijanej (typ B/C/D + prad znamionowy 6-63A)"
    - "Uzytkownik moze recznie skorygowac wartosc Ia po wyborze z listy"
    - "Staly wiersz Tablica rozdzielcza ma pelne pola edycji i obliczen"
    - "Wybor tw z listy 0.2s / 0.4s / 5s dziala"
  artifacts:
    - path: "index.html"
      provides: "Pelna tabela Zal. 1 SWZ z wszystkimi kolumnami, obliczeniami i ocena"
      contains: "renderAttachment1"
  key_links:
    - from: "input[data-field=Zs]"
      to: "calcSWZRow()"
      via: "input event -> AppState update -> EventBus -> Calculator -> DOM update"
      pattern: "calcSWZRow"
    - from: "select[data-field=baseType] + select[data-field=baseCurrent]"
      to: "getIa(type, rating)"
      via: "change event -> update AppState -> recalculate Ia -> update Id/Zsmax"
      pattern: "getIa.*baseType.*baseCurrent"
    - from: "input[data-field=Ia] (reczna korekta)"
      to: "AppState row.Ia"
      via: "Jesli row.Ia !== null to uzyj recznej wartosci, nie z PROTECTION_DB"
      pattern: "row\\.Ia.*!==.*null"
---

<objective>
Zaimplementowac kompletna tabele Zalacznika 1 (SWZ) z wszystkimi 13 kolumnami, automatycznymi obliczeniami Id/Zsmax, baza zabezpieczen B/C/D z lista rozwijana, reczna korekta Ia, i natychmiastowa ocena POZYTYWNA/NEGATYWNA.

Purpose: Zalacznik 1 jest najwazniejszym i najbardziej zlozonym formularzem w protokole. Zawiera baze zabezpieczen, obliczenia impedancji petli zwarcia i automatyczna ocene - to rdzen wartosci aplikacji.
Output: Dzialajacy Zal. 1 z obliczeniami i ocena.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-formularze-i-obliczenia/01-RESEARCH.md
@.planning/phases/01-formularze-i-obliczenia/01-01-SUMMARY.md
@reference-protokol-extracted.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pelna tabela Zal. 1 z kolumnami, selectami i inputami</name>
  <files>index.html</files>
  <action>
Zastap szkieletowa wersje renderAttachment1() pelna implementacja tabeli SWZ.

**Naglowek tabeli (4-wierszowy, jak we wzorcu referencyjnym):**

Wiersz 1: Lp. | Obwod - numer gniazda | Zabezpieczenia (colspan=4) | Usk | Ia | Id [A] | Zs | Zs max | tw | Ocena
Wiersz 2: (puste 2 kol) | dodatkowe (colspan=2) | podstawowe (colspan=2) | [V] | [A] | [A] | [Omega] | [Omega] | [s] | (puste)
Wiersz 3: (puste 2 kol) | typ | prad | typ | prad I-delta-n | (puste reszta)
Wiersz 4: (puste 2 kol) | - | [A] | - | [A] | (puste reszta)

Uzyj `<thead>` z 4 wierszami `<tr>`. Kolumny thead z odpowiednimi `colspan` i `rowspan`.
Styl: naglowek z `bg-gray-50 text-xs text-center border` na kazdej komorce.

**Staly wiersz "Tablica rozdzielcza" (SWZ-01) w `<tbody>`:**

Pierwszy wiersz body renderowany z `AppState.swzFixedRow`:
- Lp. = 1 (stale)
- Obwod = "Zabezpieczenie glowne" (tekst, nie-edytowalny)
- Zabezpieczenia dodatkowe typ: input text `data-field="protType" data-row-id="fixed"`
- Zabezpieczenia dodatkowe prad: input number `data-field="protCurrent" data-row-id="fixed"`
- Zabezpieczenia podstawowe typ: select B/C/D `data-field="baseType" data-row-id="fixed"`
- Zabezpieczenia podstawowe prad: select z PROTECTION_DB ratings `data-field="baseCurrent" data-row-id="fixed"`
- Usk: input number step="0.1" `data-field="Usk" data-row-id="fixed"`
- Ia: input number `data-field="Ia" data-row-id="fixed"` - EDYTOWALNE (PROT-03). Placeholder = wartosc z getIa(). Jesli uzytkownik wpisze wartosc, ta wartosc jest uzywana zamiast PROTECTION_DB.
- Id: `<td class="id-cell text-right">` - tylko wyswietlanie, wyliczone
- Zs: input number step="0.001" `data-field="Zs" data-row-id="fixed"`
- Zsmax: `<td class="zsmax-cell text-right">` - tylko wyswietlanie
- tw: select z opcjami 0.2 / 0.4 / 5 `data-field="tw" data-row-id="fixed"` (SWZ-06). Domyslne: 5
- Ocena: `<td class="verdict-cell text-center font-bold">` - POZYTYWNA (zielona text-green-700) / NEGATYWNA (czerwona text-red-700)

**Wiersze dynamiczne (per sekcja/podsekcja):**

Kazdy wiersz renderowany z `AppState.attachment1.rowsBySubsection[sub.id]`:
- Lp. = obliczane w renderze (getLpNumber, nie z AppState)
- Obwod: input text `data-field="circuit"`
- Zabezpieczenia dodatkowe typ: input text `data-field="protType"` (np. "40/4P/003" - typ RCD)
- Zabezpieczenia dodatkowe prad: input number `data-field="protCurrent"` (np. 0.03 A = 30mA)
- Zabezpieczenia podstawowe typ: `<select data-field="baseType">` z opcjami B, C, D
- Zabezpieczenia podstawowe prad: `<select data-field="baseCurrent">` - opcje generowane dynamicznie z `PROTECTION_DB[row.baseType].ratings`

  WAZNE: Przy zmianie baseType, opcje baseCurrent musza sie odswiezyc (re-render). Wszystkie charakterystyki maja te same ratings [6..63], ale to moze sie zmienic.

- Usk: input number, domyslna wartosc 230 w nowym wierszu (z `createNewSWZRow`)
- Ia: input number, EDYTOWALNE (PROT-03). Wyswietl placeholder z getIa(). Jesli pole puste (row.Ia === null), uzyj getIa(). Jesli uzytkownik wpiszal wartosc, to `row.Ia = wartosc` i ta jest uzywana.

  Zachowanie Ia (PROT-03 + Open Question 2 z RESEARCH):
  - Po wyborze B16: placeholder "80", pole puste -> obliczenia uzywaja 80
  - Uzytkownik wpisuje 70: pole = 70, obliczenia uzywaja 70
  - Uzytkownik zmienia na C16: placeholder zmienia sie na "160", ALE wartosc 70 NIE jest resetowana (zachowaj reczna korekte). Uzytkownik musi sam wyczyscic pole Ia zeby wrocic do automatycznej wartosci.

- Id: wyliczone, tylko wyswietlanie
- Zs: input number step="0.001"
- Zsmax: wyliczone, tylko wyswietlanie
- tw: select 0.2/0.4/5 (domyslne 0.2 dla nowych wierszy)
- Ocena: POZYTYWNA/NEGATYWNA/puste
- Przycisk "Usun" (juz istniejacy z Plan 01)

Wszystkie inputy i selecty z atrybutami: `data-field`, `data-row-id`, `data-sub-id`.

**Styl Tailwind:**
- Inputy: `w-full border border-gray-300 rounded px-1 py-0.5 text-sm text-center`
- Selecty: `border border-gray-300 rounded px-1 py-0.5 text-sm`
- Komorki numeryczne (Id, Zsmax): `text-right text-sm font-mono`
- Ocena POZYTYWNA: `text-green-700 font-bold`
- Ocena NEGATYWNA: `text-red-700 font-bold`
- Wiersz sekcji: `bg-gray-200 font-bold`
- Wiersz podtytulu: `bg-gray-100 italic`
- Tabela: `border-collapse text-sm`, komorki: `border border-gray-300 px-1 py-0.5`
  </action>
  <verify>
1. Zal. 1 wyswietla tabele z 4-wierszowym naglowkiem i prawidlowymi colspan
2. Staly wiersz "Zabezpieczenie glowne" ma Lp.1, selecty B/C/D, select pradow 6-63A
3. Dynamiczne wiersze maja edytowalne pola: Obwod, protType, protCurrent, baseType, baseCurrent, Usk, Ia, Zs, tw
4. Select tw ma opcje: 0.2, 0.4, 5
5. Pola Id, Zsmax, Ocena sa wyswietlane (nie edytowalne)
6. Zmiana baseType odswierza opcje baseCurrent (re-render)
  </verify>
  <done>
Pelna tabela Zal. 1 z 13 kolumnami wyrenderowana. Staly wiersz i dynamiczne wiersze maja wszystkie pola wejsciowe. Select zabezpieczen B/C/D z pradami 6-63A dziala.
  </done>
</task>

<task type="auto">
  <name>Task 2: Obliczenia SWZ, baza zabezpieczen i automatyczna ocena</name>
  <files>index.html</files>
  <action>
Podlacz event listenery do pol Zal. 1 tak, zeby kazda zmiana pola wejsciowego uruchamiala przeliczenie wiersza przez calcSWZRow() i natychmiast wyswietlala wyniki.

**Event handling (input + change):**

Rozbuduj istniejacy listener `input` na `#attachment-1` (lub na `#app`):

1. Przy zmianie KAZDEGO pola wiersza SWZ (Usk, Zs, baseType, baseCurrent, Ia, protType, protCurrent, tw):
   - Odczytaj `data-row-id` i `data-sub-id` z elementu (lub `data-row-id="fixed"` dla stalego wiersza)
   - Zaktualizuj odpowiednie pole w AppState:
     * Dla stalego wiersza: `AppState.swzFixedRow[field] = normalizedValue`
     * Dla dynamicznego: `AppState.attachment1.rowsBySubsection[subId].find(r => r.id === rowId)[field] = normalizedValue`
   - Normalizacja wartosci:
     * Pola numeryczne (Usk, Zs, protCurrent): `const val = e.target.value.trim(); normalizedValue = val === '' ? null : parseFloat(val);`
     * Pole Ia (PROT-03): `val === '' ? null : parseFloat(val)` - null oznacza "uzyj z PROTECTION_DB"
     * Selecty (baseType, baseCurrent, tw): wartosc jako string/number
   - Wywolaj obliczenie: `const result = calcSWZRow(row)` z aktualnym stanem wiersza
   - Zapisz wynik: `row.calculated = result`
   - Zaktualizuj DOM komorek wynikowych:
     * Id: `rowEl.querySelector('.id-cell').textContent = result.Id != null ? result.Id.toFixed(2) : ''`
     * Zsmax: `rowEl.querySelector('.zsmax-cell').textContent = result.Zsmax != null ? result.Zsmax.toFixed(2) : ''`
     * Ocena: `rowEl.querySelector('.verdict-cell').textContent = result.verdict || ''`
     * Klasy CSS oceny: dodaj/usun `text-green-700` / `text-red-700`

2. SPECJALNE zachowanie pola Ia:
   - Wyswietl placeholder = getIa(row.baseType, row.baseCurrent) - aktualizuj placeholder przy zmianie baseType/baseCurrent
   - Jesli pole Ia jest puste (row.Ia === null), calcSWZRow automatycznie uzyje getIa()
   - Jesli pole Ia ma wartosc (row.Ia !== null), calcSWZRow uzyje tej wartosci
   - Przy zmianie baseType/baseCurrent: NIE resetuj row.Ia (zachowaj reczna korekte - Open Question 2 z RESEARCH). Zmien TYLKO placeholder.

3. Przy zmianie baseType:
   - Zaktualizuj row.baseType w AppState
   - Jesli aktualny baseCurrent nie istnieje w nowej charakterystyce (nie powinno sie zdarzac bo B/C/D maja te same ratings, ale zabezpieczenie): ustaw domyslny baseCurrent=16
   - Zaktualizuj placeholder Ia
   - Przelicz wiersz

**Obsluzyj events `change` na selectach** (baseType, baseCurrent, tw) oprocz `input` - selecty emituja `change`, nie `input`.

**Prawidlowy przeplyw obliczen w calcSWZRow (juz zaimplementowany w Plan 01, ale zweryfikuj):**

```
Ia = (row.Ia !== null) ? row.Ia : getIa(row.baseType, row.baseCurrent)
if (!Ia || !row.Usk || !row.Zs) return { Id: null, Zsmax: null, verdict: null }
Id = roundTo3(row.Usk / row.Zs)
Zsmax = roundTo3(row.Usk / Ia)
verdict = roundTo3(row.Zs) <= Zsmax ? 'POZYTYWNA' : 'NEGATYWNA'
```

WAZNE: `roundTo3()` musi byc uzywane przy KAZDYM porownaniu i dzieleniu (decyzja z STATE.md: float precision).

**Targetowany DOM update (NIE pelny re-render):**

Zamiast wywolywac pelny `renderAttachment1()` przy kazdym keystroke:
- Znajdz `<tr>` wiersza po `data-row-id`
- Zaktualizuj TYLKO komorki wynikowe (.id-cell, .zsmax-cell, .verdict-cell)
- Pelny re-render tylko przy dodawaniu/usuwaniu wierszy/sekcji (strukturalnych zmianach)

Jesli targetowany update jest zbyt skomplikowany w kontekscie pelnego re-renderu (z zachowaniem focusu), dopuszczalny jest pelny re-render z zapamiętaniem i przywroceniem focusu:
```javascript
const activeEl = document.activeElement;
const activeField = activeEl?.dataset?.field;
const activeRowId = activeEl?.dataset?.rowId;
renderAttachment1();
if (activeField && activeRowId) {
  const el = document.querySelector(`[data-field="${activeField}"][data-row-id="${activeRowId}"]`);
  if (el) el.focus();
}
```

**Weryfikacja z danymi z wzorca referencyjnego:**

Wiersz 1 (staly): C25, Usk=236.80, Ia=250 (auto z DB: 10*25), Zs=0.68
- Id = 236.80 / 0.68 = 348.24 SPRAWDZ
- Zsmax = 236.80 / 250 = 0.95 SPRAWDZ
- Zs=0.68 <= 0.95 => POZYTYWNA SPRAWDZ

Wiersz 2: B16, Usk=234.6, Ia=80 (auto: 5*16), Zs=0.73
- Id = 234.6 / 0.73 = 321.37 SPRAWDZ
- Zsmax = 234.6 / 80 = 2.93 SPRAWDZ (roundTo3: 2.9325 -> 2.933, wyswietl 2.93)
- Zs=0.73 <= 2.93 => POZYTYWNA SPRAWDZ
  </action>
  <verify>
Test z danymi z wzorca referencyjnego:
1. Staly wiersz: wybierz C, 25, wpisz Usk=236.80, Zs=0.68 -> Id=348.24, Zsmax=0.95, POZYTYWNA
2. Dodaj wiersz: B, 16, Usk=234.6, Zs=0.73 -> Id=321.37, Zsmax=2.93, POZYTYWNA
3. Zmien Zs na 3.00 (wiecej niz Zsmax=2.93) -> ocena zmienia sie na NEGATYWNA
4. Wpisz Ia=100 recznie -> Zsmax zmienia sie na 234.6/100=2.35 (reczna korekta PROT-03)
5. Zmien baseType na C (Ia placeholder zmienia sie na 160) -> wpisana wartosc 100 pozostaje
6. Wyczysc pole Ia -> Ia wraca do auto (160 z DB), Zsmax = 234.6/160 = 1.47
7. Zmien tw na 0.4 -> wartosc sie zmienia (bez wplywu na obliczenia w tej fazie)
8. Brak bledow w konsoli przy szybkim wpisywaniu
  </verify>
  <done>
Wszystkie obliczenia Zal. 1 dzialaja: Id = Usk/Zs (SWZ-03), Zsmax = Usk/Ia (SWZ-04), ocena Zs <= Zsmax (SWZ-05). Baza zabezpieczen B/C/D z lista rozwijana (PROT-01, PROT-02). Reczna korekta Ia dziala (PROT-03). Wybor tw z listy (SWZ-06). Wyniki zgodne z danymi z wzorca referencyjnego.
  </done>
</task>

</tasks>

<verification>
- Wyrenderuj Zal. 1 z 4-wierszowym naglowkiem i 13 kolumnami
- Wpisz dane z wzorca referencyjnego: C25/Usk=236.80/Zs=0.68 -> Id=348.24, Zsmax=0.95, POZYTYWNA
- Wpisz B16/Usk=234.6/Zs=0.73 -> Id=321.37, Zsmax=2.93, POZYTYWNA
- Sprawdz reczna korekte Ia i powrot do automatycznej
- Sprawdz float precision: Zs=Zsmax (rowne wartosci) powinno dac POZYTYWNA
</verification>

<success_criteria>
1. Tabela Zal. 1 ma 13 kolumn z prawidlowym 4-wierszowym naglowkiem (SWZ-02)
2. Staly wiersz "Tablica rozdzielcza" z pelna edycja (SWZ-01)
3. Id oblicza sie automatycznie: Id = Usk/Zs (SWZ-03)
4. Zsmax oblicza sie automatycznie: Zsmax = Usk/Ia (SWZ-04)
5. Ocena pojawia sie natychmiast: Zs <= Zsmax -> POZYTYWNA (SWZ-05) z roundTo3
6. Wybor tw: 0.2s, 0.4s, 5s (SWZ-06)
7. Legenda oznaczeń pod tabela (SWZ-07)
8. Baza B/C/D z automatycznym Ia (PROT-01), lista rozwijana (PROT-02), reczna korekta (PROT-03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-formularze-i-obliczenia/01-02-SUMMARY.md`
</output>
