---
phase: 01-formularze-i-obliczenia
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Plik index.html otwiera sie w przegladarce i pokazuje zakladki Zal. 1 / Zal. 2 / Zal. 3 / Zal. 4"
    - "Uzytkownik moze dodac sekcje (np. Parter), podtytul (np. Pokój 1) i wiersz pomiarowy - sa widoczne w zakladce Zal. 1"
    - "Uzytkownik moze usunac sekcje, podtytul i wiersz - numeracja Lp. aktualizuje sie automatycznie"
    - "Po dodaniu sekcji i podtytulu w Zal. 1, ta sama sekcja i podtytul jest widoczna w Zal. 2 (DYN-06)"
    - "Staly wiersz Tablica rozdzielcza jest widoczny na gorze tabeli Zal. 1 i nie mozna go usunac"
  artifacts:
    - path: "index.html"
      provides: "Cala aplikacja - HTML + Tailwind CSS + JS (AppState, EventBus, PROTECTION_DB, Calculator, FormRenderer, FormController, init)"
      min_lines: 500
  key_links:
    - from: "FormController (event delegation)"
      to: "AppState.sections"
      via: "data-action attributes + EventBus emit"
      pattern: "data-action.*add-section|add-subsection|add-row|remove"
    - from: "EventBus"
      to: "FormRenderer"
      via: "on('sections:changed') -> renderAttachment1() + renderAttachment2()"
      pattern: "EventBus\\.on.*sections:changed"
    - from: "AppState.sections"
      to: "renderAttachment1 + renderAttachment2"
      via: "Shared sections array iterated by both renderers"
      pattern: "AppState\\.sections\\.forEach|for.*of.*AppState\\.sections"
---

<objective>
Zbudowac fundament aplikacji VoltProtokol w jednym pliku index.html: AppState jako jedyne zrodlo prawdy, EventBus (pub/sub), PROTECTION_DB (baza zabezpieczen B/C/D), Calculator (czyste funkcje obliczeniowe), system zakladek dla 4 zalacznikow, oraz dynamiczne sekcje/podtytuly/wiersze z automatyczna numeracja Lp.

Purpose: To jest szkielet calej aplikacji. Bez dzialajacego AppState + EventBus + dynamicznych sekcji zadne dalsze plany nie moga byc realizowane. DYN-06 (wspoldzielone sekcje Zal. 1 i Zal. 2) musi dzialac od poczatku - pozniejszy refaktor bylby kosztowny.
Output: Dzialajacy plik index.html z zakladkami, dynamicznymi sekcjami i szkieletami tabel dla Zal. 1-4.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-formularze-i-obliczenia/01-RESEARCH.md
@reference-protokol-extracted.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Szkielet HTML + AppState + EventBus + PROTECTION_DB + Calculator</name>
  <files>index.html</files>
  <action>
Utworz plik index.html z pelna struktura:

**HTML `<head>`:**
- `<meta charset="UTF-8">`, viewport, title "VoltProtokol - Protokol kontrolno-pomiarowy"
- Tailwind CSS v4 Play CDN: `<script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>`
- Dodaj pdfmake CDN juz teraz (do uzycia w Fazie 3): `pdfmake@0.3.5/build/pdfmake.min.js` + `vfs_fonts.min.js` z jsdelivr

**HTML `<body>`:**
- Glowny kontener `<div id="app">` z klasa `max-w-7xl mx-auto p-4`
- Naglowek h1: "Protokol kontrolno-pomiarowy PN-HD 60364-6"
- System zakladek (4 tabs): Zal. 1 - SWZ, Zal. 2 - Izolacja, Zal. 3 - RCD, Zal. 4 - Uziemienie
  - Zakladki jako buttony z `data-tab="1|2|3|4"`, aktywna zakladka z klasa `border-b-2 border-blue-600 text-blue-600`
  - Kontenery `<div id="attachment-1">` ... `<div id="attachment-4">` - tylko aktywny widoczny (reszta `hidden`)
- W kazdym kontenerze attachment: placeholder tekst "Zakladka X" (wypelniane w renderze)

**JavaScript `<script>` na koncu `<body>`:**

Sekcje kodu oddzielone komentarzami `// === NAZWA ===`:

**// === CONSTANTS ===**
```javascript
const PROTECTION_DB = Object.freeze({
  B: { multiplier: 5,  ratings: [6, 8, 10, 13, 16, 20, 25, 32, 40, 50, 63] },
  C: { multiplier: 10, ratings: [6, 8, 10, 13, 16, 20, 25, 32, 40, 50, 63] },
  D: { multiplier: 20, ratings: [6, 8, 10, 13, 16, 20, 25, 32, 40, 50, 63] }
});

function getIa(type, rating) {
  const spec = PROTECTION_DB[type];
  if (!spec) return null;
  if (!spec.ratings.includes(Number(rating))) return null;
  return spec.multiplier * Number(rating);
}

const IZOL_FIELDS_1PHASE = ['L1N', 'L1PE', 'NPE'];
const IZOL_FIELDS_3PHASE = ['L1N','L2N','L3N','L1L2','L1L3','L2L3','L1PE','L2PE','L3PE','NPE'];

function getActiveIZOLFields(phaseType) {
  return phaseType === '3' ? IZOL_FIELDS_3PHASE : IZOL_FIELDS_1PHASE;
}
```

**// === STATE ===**
AppState dokladnie wedlug wzorca z 01-RESEARCH.md Pattern 1 (linie 96-204):
- `sections: []` - wspoldzielone miedzy Zal. 1 i Zal. 2
- `swzFixedRow` - staly wiersz "Zabezpieczenie glowne" z domyslnymi: baseType='C', baseCurrent=25, Usk=null, tw='5'
- `attachment1: { rowsBySubsection: {} }` - wiersze per subsectionId
- `attachment2: { fixedRow: {...}, rowsBySubsection: {} }` - fixedRow dla WLZ, Rw=1
- `attachment3: { rows: [] }` - prosta lista, tz=300
- `attachment4: { rows: [] }` - prosta lista, Rw=10

UIState: `{ activeTab: 1 }` - tylko stan UI, nie persystowany.

**// === EVENT BUS ===**
Dokladnie wedlug wzorca z RESEARCH.md Pattern 5 (IIFE, on/emit).

**// === CALCULATOR ===**
Wszystkie 4 funkcje obliczeniowe z RESEARCH.md Pattern 3:
- `roundTo3(val)` - Math.round(val * 1000) / 1000
- `calcSWZRow(row)` - Id = Usk/Zs, Zsmax = Usk/Ia, verdict = Zs <= Zsmax. Uzyj `roundTo3()` konsekwentnie przy KAZDYM porownaniu (decyzja z STATE.md). Ia: jesli `row.Ia !== null` uzyj recznie ustawionej, inaczej `getIa(row.baseType, row.baseCurrent)`.
- `calcIZOLRow(row)` - verdict na podstawie activeFields i Rp >= Rw
- `calcRCDRow(row)` - Iw <= In AND tw <= tz
- `calcUZIEMRow(row)` - Rpo = Rp * Wk, verdict = Rpo <= Rw

**// === FORM RENDERER ===**
Puste szkielety funkcji (wypelniane w Plan 02 i 03):
- `renderTabs()` - renderuje zakladki, podswietla aktywna
- `renderAttachment1()` - placeholder "Zal. 1 - SWZ (w budowie)"
- `renderAttachment2()` - placeholder "Zal. 2 - Izolacja (w budowie)"
- `renderAttachment3()` - placeholder "Zal. 3 - RCD (w budowie)"
- `renderAttachment4()` - placeholder "Zal. 4 - Uziemienie (w budowie)"

**// === FORM CONTROLLER ===**
- `bindTabEvents()` - przelaczanie zakladek (click na data-tab -> UIState.activeTab = N -> pokaz/ukryj kontenery)

**// === INIT ===**
```javascript
function init() {
  renderTabs();
  renderAttachment1();
  renderAttachment2();
  renderAttachment3();
  renderAttachment4();
  bindTabEvents();
}
document.addEventListener('DOMContentLoaded', init);
```

WAZNE anti-patterns do unikania:
- NIE uzywaj `onclick=""` inline - tylko `data-action` + event delegation
- NIE przechowuj Lp. w AppState - obliczaj w renderze
- NIE uzywaj `parseFloat(val) || 0` - uzywaj `parseFloat(val) || null` (bo 0 jest poprawna wartoscia)
- NIE uzywaj globalnych `var` - const/let + IIFE tam gdzie potrzebne
  </action>
  <verify>
Otworz index.html w przegladarce:
1. Strona laduje sie bez bledow w konsoli (F12 -> Console)
2. Widac 4 zakladki: "Zal. 1 - SWZ", "Zal. 2 - Izolacja", "Zal. 3 - RCD", "Zal. 4 - Uziemienie"
3. Klikniecie zakladki przelacza widoczny kontener
4. W konsoli przegladarki: `getIa('B', 16)` zwraca 80, `getIa('C', 25)` zwraca 250
5. W konsoli: `roundTo3(0.1 + 0.2)` zwraca 0.3 (nie 0.30000000000000004)
6. W konsoli: `calcSWZRow({baseType:'B', baseCurrent:16, Ia:null, Usk:234.6, Zs:0.73, tw:'0.2'})` zwraca obiekt z Id, Zsmax, verdict='POZYTYWNA'
  </verify>
  <done>
Plik index.html otwiera sie w przegladarce. Zakladki przelaczaja widok. AppState, EventBus, PROTECTION_DB, Calculator sa zdefiniowane i dzialaja poprawnie (zweryfikowane w konsoli). Kazdy attachment ma swoj kontener.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dynamiczne sekcje, podtytuly i wiersze + automatyczna numeracja Lp.</name>
  <files>index.html</files>
  <action>
Rozbuduj index.html o dynamiczne zarzadzanie sekcjami, podtytulami i wierszami. To jest kluczowa funkcjonalnosc DYN-01 do DYN-06.

**Rozbuduj renderAttachment1():**

Wyrenderuj pelna strukture Zal. 1 w kontenerze `#attachment-1`:

1. Naglowek: "Zalacznik nr 1 - Skutecznosc ochrony przez samoczynne wylaczenie zasilania"
2. Przycisk "Dodaj sekcje" (`data-action="add-section"`) nad tabela
3. Tabela HTML `<table>` z klasa `w-full border-collapse`:
   - Staly wiersz "Tablica rozdzielcza - zabezpieczenie glowne" (SWZ-01) - wyrenderowany z `AppState.swzFixedRow`. Na razie uproszczona wersja: pokaz kolumny Lp(1), Obwod("Zabezpieczenie glowne"), reszta komorek pusta (pelna implementacja w Plan 02)
   - Iteracja po `AppState.sections`:
     - Wiersz sekcji: `<tr class="bg-gray-200 font-bold"><td colspan="13">[tytul edytowalny input] + przycisk "Dodaj podtytul" + przycisk "Usun sekcje"</td></tr>`
     - Iteracja po `section.subsections`:
       - Wiersz podtytulu: `<tr class="bg-gray-100 italic"><td colspan="13">[tytul edytowalny input] + przycisk "Dodaj wiersz" + przycisk "Usun podtytul"</td></tr>`
       - Iteracja po `AppState.attachment1.rowsBySubsection[sub.id]`:
         - Wiersz danych: `<tr data-row-id="..." data-sub-id="...">` z Lp. obliczonym w renderze (DYN-05) + komorki na dane (puste szkielety na razie - pelne w Plan 02)
         - Przycisk "Usun" w ostatniej kolumnie

4. Legenda pod tabela (SWZ-07): lista oznaczeń In, Ia, Id, tw, Zs, Zsmax, Usk z trescia z wzorca referencyjnego

**AUTOMATYCZNA NUMERACJA Lp. (DYN-05):**
Funkcja `getLpNumber(sections, subId, rowId)` wg wzorca z RESEARCH.md Pattern 7. Lp. zaczyna od 1 (staly wiersz = Lp.1), wiersze dynamiczne od 2 w gore. Lp. NIGDY nie jest przechowywane w AppState.

**Rozbuduj renderAttachment2():**

Wyrenderuj szkielet Zal. 2 w `#attachment-2`:
1. Naglowek: "Zalacznik nr 2 - Rezystancja izolacji"
2. BEZ przycisku "Dodaj sekcje" - sekcje sa wspoldzielone z Zal. 1 (DYN-06). Pokaz informacje: "Sekcje zarzadzane z Zal. 1"
3. Tabela:
   - Staly wiersz WLZ z `AppState.attachment2.fixedRow` (uproszczony szkielet - pelna implementacja w Plan 03)
   - Te same sekcje i podsekcje co Zal. 1 (`AppState.sections`):
     - Wiersz sekcji (tylko tytul, BEZ mozliwosci edycji - edycja w Zal. 1)
     - Wiersz podtytulu (tytul + przycisk "Dodaj wiersz" dla Zal. 2 + BEZ mozliwosci edycji nazwy)
     - Wiersze `AppState.attachment2.rowsBySubsection[sub.id]` (szkielety - pelne w Plan 03)
4. Legenda pod tabela (IZOL-07): Rp, Rw

**Renderowanie Zal. 3 i Zal. 4:**
Prostsze szkielety (bez sekcji/podsekcji):
- Zal. 3: naglowek + przycisk "Dodaj wiersz" + pusta tabela + legenda (RCD-05)
- Zal. 4: naglowek + przycisk "Dodaj wiersz" + pusta tabela + legenda (UZIEM-06: RE, Wk, Rpo, Rw)

**FORM CONTROLLER - event delegation:**

Jeden listener `click` na `#app` (lub na kazdym `#attachment-N`) obslugujacy:
- `data-action="add-section"`: tworzy nowa sekcje w `AppState.sections` z `crypto.randomUUID()`, inicjalizuje pusta tablice subsections. EventBus.emit('sections:changed').
- `data-action="add-subsection"` + `data-section-id`: tworzy podsekcje, inicjalizuje `AppState.attachment1.rowsBySubsection[newSubId] = []` ORAZ `AppState.attachment2.rowsBySubsection[newSubId] = []` (Pitfall 5). EventBus.emit('sections:changed').
- `data-action="add-row-swz"` + `data-sub-id`: tworzy wiersz SWZ wg `createNewSWZRow()` z RESEARCH.md. EventBus.emit('attachment1:changed').
- `data-action="add-row-izol"` + `data-sub-id`: tworzy wiersz IZOL. EventBus.emit('attachment2:changed').
- `data-action="add-row-rcd"`: tworzy wiersz RCD w `AppState.attachment3.rows`. EventBus.emit('attachment3:changed').
- `data-action="add-row-uziem"`: tworzy wiersz UZIEM w `AppState.attachment4.rows`. EventBus.emit('attachment4:changed').
- `data-action="remove-section"` + `data-section-id`: usuwa sekcje + wszystkie podsekcje + wszystkie wiersze z rowsBySubsection. EventBus.emit('sections:changed').
- `data-action="remove-subsection"` + `data-section-id` + `data-sub-id`: usuwa podsekcje + wiersze. EventBus.emit('sections:changed').
- `data-action="remove-row"` + `data-row-id` + `data-sub-id` + `data-attachment`: usuwa wiersz z odpowiedniego rowsBySubsection. EventBus.emit odpowiedni event.

Listener `input` na `#app` obslugujacy:
- `data-field="section-title"` + `data-section-id`: aktualizuje `section.title` w AppState.sections. EventBus.emit('sections:changed') - to powoduje re-render Zal. 2 tez (DYN-06).
- `data-field="subsection-title"` + `data-section-id` + `data-sub-id`: aktualizuje tytul podsekcji. EventBus.emit('sections:changed').

**EventBus subscriptions:**
- `EventBus.on('sections:changed', () => { renderAttachment1(); renderAttachment2(); })` - DYN-06
- `EventBus.on('attachment1:changed', renderAttachment1)`
- `EventBus.on('attachment2:changed', renderAttachment2)`
- `EventBus.on('attachment3:changed', renderAttachment3)`
- `EventBus.on('attachment4:changed', renderAttachment4)`

**Aktualizuj init():**
Dodaj jedno domyslne startowe: jedna sekcja "Parter" z jedna podsekcja "Obwod gniazd wtykowych" i jednym pustym wierszem w Zal. 1 - zeby formularz nie byl zupelnie pusty przy starcie. Dodaj tez zainicjalizowany rowsBySubsection dla Zal. 2 (DYN-06).

WAZNE:
- Przy usuwaniu sekcji usun tez wpisy z OBU rowsBySubsection (attachment1 I attachment2)
- Przy tworzeniu podsekcji inicjalizuj OBIE rowsBySubsection od razu (Pitfall 5 z RESEARCH.md)
- Nazwy sekcji w Zal. 2 sa read-only (edycja tylko z Zal. 1) - wyswietl jako tekst, nie input
- Uzyj `crypto.randomUUID()` dla wszystkich nowych id
  </action>
  <verify>
Otworz index.html w przegladarce:
1. Zal. 1 pokazuje staly wiersz "Tablica rozdzielcza" (Lp.1) + domyslna sekcje "Parter" z podtytul i wierszem
2. Kliknij "Dodaj sekcje" - pojawia sie nowa sekcja z edytowalnym tytulem
3. Kliknij "Dodaj podtytul" w nowej sekcji - pojawia sie podtytul
4. Kliknij "Dodaj wiersz" w podtytule - pojawia sie wiersz z kolejnym Lp.
5. Usun wiersz - Lp. nastepnych wierszy aktualizuje sie
6. Przelacz na Zal. 2 - widac te same sekcje i podtytuly co w Zal. 1
7. Zmien nazwe sekcji w Zal. 1 (wpisz "Piętro") - przelacz na Zal. 2, nazwa tez sie zmienila
8. W Zal. 2 NIE MA mozliwosci edycji nazw sekcji (sa read-only)
9. W Zal. 3 i 4: przycisk "Dodaj wiersz" dodaje wiersz
10. Brak bledow w konsoli przy wszystkich operacjach
  </verify>
  <done>
Dynamiczne sekcje (DYN-01), podtytuly (DYN-02), wiersze (DYN-03) dzialaja. Usuwanie dziala (DYN-04). Numeracja Lp. aktualizuje sie automatycznie (DYN-05). Sekcje sa wspoldzielone miedzy Zal. 1 i Zal. 2 - zmiana w jednym odzwierciedla sie w drugim (DYN-06). Legendy pod tabelami sa widoczne.
  </done>
</task>

</tasks>

<verification>
- Otworz index.html w Chrome/Firefox
- Sprawdz brak bledow w konsoli (F12)
- Przetestuj pelny cykl: dodaj sekcje -> dodaj podtytul -> dodaj 3 wiersze -> usun srodkowy -> sprawdz Lp.
- Przelacz miedzy Zal. 1 i Zal. 2 - sekcje sie synchronizuja
- W konsoli: zweryfikuj `AppState.sections` ma poprawna strukture
- W konsoli: `calcSWZRow(...)` zwraca poprawne wyniki
</verification>

<success_criteria>
1. index.html otwiera sie bez bledow, zakladki przelaczaja widok
2. AppState, EventBus, PROTECTION_DB, Calculator dzialaja (zweryfikowane w konsoli)
3. Sekcje/podtytuly/wiersze mozna dodawac i usuwac we wszystkich zalacznikach
4. Numeracja Lp. aktualizuje sie automatycznie po dodaniu/usunieciu
5. Sekcje wspoldzielone miedzy Zal. 1 i Zal. 2 (DYN-06) - zmiana nazwy w Zal. 1 widoczna w Zal. 2
6. Legendy oznaczeń widoczne pod kazdym zalacznikiem
</success_criteria>

<output>
After completion, create `.planning/phases/01-formularze-i-obliczenia/01-01-SUMMARY.md`
</output>
