---
phase: 03-eksport-i-dane
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Kliknięcie przycisku Eksportuj PDF pobiera plik .pdf na dysk"
    - "PDF zawiera formularz główny (numer, obiekt, wykonawca, przyrządy, ocena, orzeczenie)"
    - "PDF zawiera Zał. 1 (SWZ) jako tabelę z 4-wierszowym nagłówkiem i auto-paginacją"
    - "PDF zawiera Zał. 2 (izolacja) w orientacji landscape"
    - "PDF zawiera Zał. 3 (RCD) i Zał. 4 (uziemienie) jako tabele portrait"
    - "Polskie znaki (ą,ę,ś,ź,ć,ó,ł,ń,ż) wyświetlają się poprawnie w PDF"
    - "PDF jest czarno-biały z numeracją stron w stopce"
    - "Sekcje i podsekcje renderują się jako full-width merged rows w tabelach PDF"
  artifacts:
    - path: "index.html"
      provides: "Sekcja // === PDF EXPORTER === z buildDocDefinition(), exportPDF(), build*Content()"
      contains: "pdfMake.createPdf"
  key_links:
    - from: "exportPDF()"
      to: "pdfMake.createPdf(docDefinition).download()"
      via: "buildDocDefinition() buduje DDO z AppState"
      pattern: "pdfMake\\.createPdf"
    - from: "buildAttachment1Content()"
      to: "AppState.swzFixedRow, AppState.sections, AppState.attachment1.rowsBySubsection"
      via: "odczyt danych z AppState → DDO table body"
      pattern: "AppState\\.swzFixedRow"
    - from: "buildAttachment2Content()"
      to: "AppState.attachment2"
      via: "odczyt danych z AppState → DDO table body, pageOrientation landscape"
      pattern: "pageOrientation.*landscape"
---

<objective>
Implementacja PDFExporter — moduł generujący kompletny protokół PDF z danych AppState przy użyciu pdfmake 0.3.5. PDF zawiera formularz główny, 4 załączniki jako tabele z nagłówkami, sekcjami i podsekcjami, auto-paginację, orientację landscape dla Zał. 2, polskie znaki i numerację stron.

Purpose: Spełnienie wymagań EXP-01 (przycisk PDF), EXP-02 (czarno-biały, numeracja stron), EXP-03 (auto-paginacja), EXP-04 (polskie znaki).
Output: Sekcja `// === PDF EXPORTER ===` w index.html + przycisk "Eksportuj PDF" w nagłówku aplikacji.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-eksport-i-dane/03-RESEARCH.md
@.planning/phases/02-kompletnosc-normowa/02-01-SUMMARY.md
@reference-protokol-extracted.md
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: buildDocDefinition() z formularzem głównym i wszystkimi 4 załącznikami</name>
  <files>index.html</files>
  <action>
Dodaj sekcję `// === PDF EXPORTER ===` w index.html PRZED sekcją `// === INIT ===`.

Zaimplementuj następujące funkcje:

**1. exportPDF()** — główna funkcja wywoływana z przycisku:
- Wywołuje `buildDocDefinition()` → `pdfMake.createPdf(dd).download('protokol-' + (AppState.form.protocolNumber || 'draft').replace(/\//g, '-') + '.pdf')`

**2. buildDocDefinition()** — buduje cały DDO:
- `pageSize: 'A4'`, `pageOrientation: 'portrait'`, `pageMargins: [40, 60, 40, 60]`
- `defaultStyle: { font: 'Roboto', fontSize: 9 }` — Roboto z vfs_fonts.min.js pokrywa polskie znaki Latin Extended-A
- `footer: function(currentPage, pageCount) { return { text: currentPage + ' / ' + pageCount, alignment: 'center', fontSize: 8, margin: [0, 10, 0, 0] }; }`
- `content: [...buildFormMainContent(), ...buildAttachment1Content(), { stack: buildAttachment2Content(), pageOrientation: 'landscape', pageBreak: 'before' }, { stack: buildAttachment3Content(), pageOrientation: 'portrait', pageBreak: 'before' }, ...buildAttachment4Content()]`
- UWAGA: Zał. 2 opakowany w `{ stack: [...], pageOrientation: 'landscape', pageBreak: 'before' }` — bezpieczniejszy pattern niż pageOrientation bezpośrednio na table. Zał. 3 z `pageOrientation: 'portrait'` przywraca portrait po landscape.

**3. buildFormMainContent()** — formularz główny (strony 1-2):
- Tytuł: `{ text: 'PROTOKÓŁ KONTROLNO POMIAROWY NR ' + AppState.form.protocolNumber, bold: true, fontSize: 14, alignment: 'center', margin: [0, 0, 0, 15] }`
- Punkt 1 "Obiekt badany": bold label + tekst z AppState.form.objectName, objectParcel, objectAddress
- Punkt 2 "Wykonawca": AppState.form.executorName + numery SEP (executorSepE, executorSepD)
- Punkt 3 "Warunki badań": data (AppState.form.testDate), temperatura (testTemp), tabela przyrządów pomiarowych (3 kolumny: Wykonane pomiary, Przyrządy pomiarowe, Nr świadectwa wzorcowania) — 4 wiersze z AppState.form.instruments, headerRows: 1
- Punkt 4 "Ocena wykonanych badań": tabela oceny końcowej (3 kolumny: Lp, Badanie, Ocena) — 6 wierszy. Wiersze 1-2 stałe ("Oględziny" POZYTYWNY, "Badanie ciągłości" POZYTYWNY). Wiersze 3-6 z `calcAttachmentVerdict('swz'|'izol'|'rcd'|'uziem')`. headerRows: 1
- Punkt 5 "Orzeczenie": tekst z `calcOrzeczenie()` — bold, orzeczenie o zdatności. Data następnego badania z `calcNextTestDate()`.
- Na końcu: linie podpisu (wykonawca + miejscowość i data)

**4. buildAttachment1Content()** — Załącznik 1 SWZ (portrait):
- Tytuł: `{ text: 'ZAŁĄCZNIK NR 1...', bold: true, fontSize: 11, pageBreak: 'before', margin: [0, 0, 0, 10] }`
- Tabela z `headerRows: 4` (4-wierszowy nagłówek z colSpan/rowSpan — patrz RESEARCH Pattern 2)
- 13 kolumn: Lp, Obwód, Zabezpieczenia dodatkowe (typ, prąd), Zabezpieczenia podstawowe (typ, prąd IΔn), Usk, Ia, Id, Zs, Zsmax, tw, Ocena
- Szerokości: `[20, '*', 25, 30, 25, 35, 30, 30, 30, 30, 35, 25, 55]`
- Body: stały wiersz (swzFixedRow) + dynamiczne wiersze z sekcjami/podsekcjami
- KRYTYCZNE: Każdy wiersz musi mieć DOKŁADNIE 13 elementów. Przy colSpan/rowSpan — placeholdery `{}` (nie `''`).
- Sekcje: `makeSectionRow(title, 13)` z `fillColor: '#d1d5db'`, bold, colSpan: 13
- Podsekcje: `makeSubsectionRow(title, 13)` z `fillColor: '#f3f4f6'`, italics, colSpan: 13
- Wiersz danych: [lp, circuit, protType, protCurrent||'', baseType, baseCurrent||'', Usk||'', Ia||'', Id||'', Zs||'', Zsmax||'', tw, verdict] — Ia z `row.Ia || getIa(row.baseType, row.baseCurrent) || ''`, Id/Zsmax/verdict z row.calculated
- Numeracja Lp: ciągła w ramach całej tabeli (obliczana w trakcie budowania body, pomijając sekcje/podsekcje)
- Layout: `{ hLineWidth: () => 0.5, vLineWidth: () => 0.5 }` — cienkie linie, czarno-białe (EXP-02)

**5. buildAttachment2Content()** — Załącznik 2 Izolacja (landscape):
- Zwraca TABLICĘ elementów (nie pojedynczy element — bo opakowanie w stack robi buildDocDefinition)
- Tytuł + tabela z `headerRows: 2` (2-wierszowy nagłówek)
- 15 kolumn: Lp, Nazwa obwodu, Typ przewodu, L1-N, L2-N, L3-N, L1-L2, L1-L3, L2-L3, L1-PE, L2-PE, L3-PE, N-PE, Rw, Ocena
- Szerokości (landscape, ~761pt): `[20, '*', 40, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 25, 50]`
- Body: stały wiersz fixedRow + dynamiczne wiersze z sekcjami/podsekcjami (identycznie jak Zał. 1)
- Pola Rp: wyświetl wartość jeśli phaseType pasuje, inaczej `'-'` (1-faz: L1N, L1PE, NPE aktywne; 3-faz: wszystkie 10)
- Ocena z row.calculated.verdict

**6. buildAttachment3Content()** — Załącznik 3 RCD (portrait):
- Zwraca TABLICĘ elementów
- Tytuł + tabela z `headerRows: 1`
- 8 kolumn: Lp, Typ wyłącznika, TEST TAK/NIE, In [A], Iw [A], tw [ms], tz [ms], Ocena
- Body z AppState.attachment3.rows — płaska lista (bez sekcji)
- Szerokości: `[25, '*', 60, 40, 40, 40, 40, 55]`

**7. buildAttachment4Content()** — Załącznik 4 Uziemienie (portrait):
- `pageBreak: 'before'` na tytule
- Tabela z `headerRows: 1`
- 7 kolumn: Lp, Nazwa, Rp [Ω], Wk, Rpo [Ω], Rw [Ω], Ocena
- Body z AppState.attachment4.rows — płaska lista
- Szerokości: `[25, '*', 50, 50, 50, 50, 55]`

**8. Helpery:**
- `makeSectionRow(title, numCols)` — wiersz sekcji (colSpan, fillColor, bold)
- `makeSubsectionRow(title, numCols)` — wiersz podsekcji (colSpan, fillColor, italics)
- `pdfVal(v)` — helper: `v != null ? String(v) : ''` — konwersja wartości do stringa dla DDO

**Polskie znaki (EXP-04):** Roboto z vfs_fonts.min.js obsługuje Latin Extended-A. Upewnij się, że `defaultStyle.font` jest 'Roboto'. NIE używaj Helvetica/Times/Courier (tylko ANSI).

**Czarno-biały (EXP-02):** Brak kolorów w tekście. Jedyne kolory to fillColor sekcji (#d1d5db) i podsekcji (#f3f4f6) — szarości czytelne w druku B&W. Ocena POZYTYWNA/NEGATYWNA jako tekst (bez koloru).
  </action>
  <verify>
Otwórz index.html w przeglądarce. Wypełnij przykładowe dane w formularzu (numer protokołu, obiekt, wykonawca). Dodaj sekcję "Parter" z podsekcją "Obwód oświetlenia" i kilka wierszy pomiarowych w Zał. 1 z danymi (Zs, baseType, baseCurrent). Dodaj wiersze w Zał. 3 i 4. Sprawdź czy w konsoli przeglądarki nie ma błędów JS. Wyszukaj tekst `pdfMake.createPdf` w kodzie.
  </verify>
  <done>
Funkcje buildDocDefinition(), exportPDF(), buildFormMainContent(), buildAttachment1Content(), buildAttachment2Content(), buildAttachment3Content(), buildAttachment4Content() istnieją w sekcji `// === PDF EXPORTER ===`. Kod nie zawiera błędów składniowych.
  </done>
</task>

<task type="auto">
  <name>Task 2: Przycisk "Eksportuj PDF" w nagłówku + podpięcie</name>
  <files>index.html</files>
  <action>
Dodaj przycisk "Eksportuj PDF" do nagłówka aplikacji (obok `<h1>`). Przycisk widoczny z każdej zakładki.

**Zmiana HTML:**
W sekcji `<div id="app">` zmień `<h1>` na layout z flexem:
```html
<div class="flex items-center justify-between mb-6">
  <h1 class="text-2xl font-bold">Protokół kontrolno-pomiarowy PN-HD 60364-6</h1>
  <button id="btn-export-pdf" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 font-medium text-sm">
    Eksportuj PDF
  </button>
</div>
```

**Podpięcie w sekcji INIT:**
W bloku `// === INIT ===` dodaj:
```javascript
document.getElementById('btn-export-pdf').addEventListener('click', exportPDF);
```

NIE używaj EventBus — prosty click handler wystarczy (pattern z RESEARCH Pattern 8).
  </action>
  <verify>
Otwórz index.html w przeglądarce. Przycisk "Eksportuj PDF" jest widoczny w prawym górnym rogu obok tytułu. Kliknięcie przycisku pobiera plik .pdf. PDF zawiera formularz główny, 4 załączniki. Polskie znaki wyświetlają się poprawnie. Zał. 2 jest w orientacji landscape. Numeracja stron w stopce.
  </verify>
  <done>
Przycisk "Eksportuj PDF" istnieje w nagłówku. Kliknięcie wywołuje exportPDF(). PDF pobiera się na dysk z poprawną treścią protokołu.
  </done>
</task>

</tasks>

<verification>
1. Otwórz index.html w przeglądarce
2. Wypełnij dane formularza głównego (numer, obiekt, wykonawca, przyrządy)
3. Dodaj sekcję "Parter" z podsekcją i wierszami w Zał. 1 (wpisz Zs, wybierz zabezpieczenie)
4. Dodaj wiersze w Zał. 3 i 4 z danymi
5. Kliknij "Eksportuj PDF"
6. Otwórz pobrany PDF:
   - Formularz główny z danymi (str. 1-2)
   - Zał. 1 SWZ — tabela portrait z nagłówkiem (str. 3+)
   - Zał. 2 Izolacja — tabela landscape (str. N)
   - Zał. 3 RCD — tabela portrait (str. N+1)
   - Zał. 4 Uziemienie — tabela portrait (str. N+2)
7. Polskie znaki: sprawdź ą, ę, ś, ź, ć, ó, ł, ń, ż
8. Numeracja stron w stopce: "1 / N"
9. Czarno-biały — brak kolorowych fontów
</verification>

<success_criteria>
- Przycisk "Eksportuj PDF" pobiera plik .pdf
- PDF zawiera formularz główny + 4 załączniki
- Polskie znaki wyświetlają się poprawnie
- Zał. 2 w landscape, reszta w portrait
- Numeracja stron w stopce
- Auto-paginacja tabel (headerRows powtarzają się)
- Sekcje/podsekcje jako merged rows z szarym tłem
</success_criteria>

<output>
After completion, create `.planning/phases/03-eksport-i-dane/03-01-SUMMARY.md`
</output>
