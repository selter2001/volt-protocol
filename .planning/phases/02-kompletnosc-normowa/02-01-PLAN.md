---
phase: 02-kompletnosc-normowa
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [index.html]
autonomous: true

must_haves:
  truths:
    - "Zakladka 'Protokol' jest widoczna jako pierwsza zakladka (tab 0) i domyslnie aktywna"
    - "Uzytkownik moze wpisac numer protokolu (auto-generowany RRRR/MM/001, edytowalny)"
    - "Uzytkownik moze wpisac dane obiektu (nazwa, adres, dzialka)"
    - "Uzytkownik moze wpisac dane wykonawcy (imie nazwisko, nr SEP eksploatacja, nr SEP dozor)"
    - "Uzytkownik moze wpisac date badania i temperature otoczenia"
    - "Uzytkownik moze wpisac przyrządy pomiarowe (nazwa, nr swiadectwa) dla 4 typow pomiarow"
    - "Tabela oceny koncowej generuje sie automatycznie z wynikami per zalacznik (POZYTYWNY/NEGATYWNY/—)"
    - "Orzeczenie o zdatnosci instalacji wyswietla sie z automatyczna data nastepnego badania (+5 lat)"
    - "Zmiana danych w zalacznikach 1-4 automatycznie aktualizuje ocene koncowa i orzeczenie bez gubienia focusu"
  artifacts:
    - path: "index.html"
      provides: "AppState.form, escapeHtml, generateProtocolNumber, parseLocalDate, renderFormTab, handleFormFieldChange, calcFinalAssessment, calcOrzeczenie, updateFinalAssessmentDisplay, updateOrzeczenieDisplay"
      contains: "AppState.form"
  key_links:
    - from: "renderFormTab()"
      to: "AppState.form"
      via: "reads form fields for rendering"
      pattern: "AppState\\.form\\."
    - from: "handleFormFieldChange()"
      to: "AppState.form"
      via: "writes user input to state"
      pattern: "handleFormFieldChange"
    - from: "calcFinalAssessment()"
      to: "AppState.attachment1/2/3/4"
      via: "scans all attachment verdicts"
      pattern: "calcAttachmentVerdict"
    - from: "EventBus.on('attachment*:changed')"
      to: "updateFinalAssessmentDisplay()"
      via: "targeted DOM update for assessment cells"
      pattern: "EventBus\\.on\\('attachment"
---

<objective>
Dodaj zakladke "Protokol" (tab 0) z kompletnym formularzem glownym protokolu: metadane (numer, obiekt, wykonawca, data, temperatura), tabela przyrzadow pomiarowych, automatyczna tabela oceny koncowej i orzeczenie o zdatnosci instalacji.

Purpose: Protokol jest kompletny zgodnie z PN-HD 60364-6 — zawiera wszystkie dane wymagane norma obok danych pomiarowych z Fazy 1.
Output: Rozszerzony index.html z zakladka "Protokol" jako tab 0, AppState.form, 7 wymagan FORM-01 do FORM-07 zaimplementowanych.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-kompletnosc-normowa/02-RESEARCH.md
@.planning/phases/01-formularze-i-obliczenia/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: AppState.form + tab Protokol + renderFormTab (FORM-01 do FORM-05)</name>
  <files>index.html</files>
  <action>
Rozszerz istniejacy index.html o zakladke "Protokol" jako tab 0 z polami formularza glownego.

**1. Dodaj `escapeHtml()` (przed sekcja STATE):**
```javascript
function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&amp;/g, '&amp;amp;')
    .replace(/</g, '&amp;lt;')
    .replace(/>/g, '&amp;gt;')
    .replace(/"/g, '&amp;quot;');
}
```

**2. Dodaj `generateProtocolNumber()` i `parseLocalDate()` (po escapeHtml):**
```javascript
function generateProtocolNumber() {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  return `${yyyy}/${mm}/001`;
}

function parseLocalDate(dateStr) {
  if (!dateStr) return null;
  const [yyyy, mm, dd] = dateStr.split('-').map(Number);
  return new Date(yyyy, mm - 1, dd);
}
```

**3. Rozszerz AppState o obiekt `form` (po istniejacych polach, przed UIState):**
```javascript
form: {
  protocolNumber: '',
  objectName: '',
  objectAddress: '',
  objectParcel: '',
  executorName: '',
  executorSepE: '',
  executorSepD: '',
  testDate: '',
  testTemp: null,
  instruments: [
    { type: 'SWZ',   name: '', serial: '', calibration: '' },
    { type: 'RCD',   name: '', serial: '', calibration: '' },
    { type: 'IZOL',  name: '', serial: '', calibration: '' },
    { type: 'UZIEM', name: '', serial: '', calibration: '' }
  ]
}
```

**4. Dodaj stale `INSTRUMENT_LABELS` (po IZOL_FIELDS_3PHASE):**
```javascript
const INSTRUMENT_LABELS = {
  SWZ:   'Pomiar skutecznosci ochrony przeciwporazeniowej przez samoczynne wylaczenie zasilania',
  RCD:   'Pomiar wylacznikow roznicowo-pradowych',
  IZOL:  'Pomiar rezystancji izolacji',
  UZIEM: 'Pomiar rezystancji uziomu'
};
```

**5. Zmien HTML zakladek — dodaj button "Protokol" PRZED istniejacymi:**
```html
<button data-tab="0" class="px-4 py-2 font-medium border-b-2 border-blue-600 text-blue-600">Protokol</button>
<button data-tab="1" class="px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700">Zal. 1 - SWZ</button>
```
Tab 0 domyslnie aktywny (border-blue-600). Tab 1 zmien na nieaktywny (border-transparent).

**6. Dodaj kontener `<div id="attachment-0"></div>` PRZED `<div id="attachment-1">`.**

**7. Zmien `UIState.activeTab` na `0` (domyslnie zakladka Protokol).**

**8. Zaktualizuj `renderTabs()`:**
- Zmien petla `for (let i = 1; i <= 4; i++)` na `for (let i = 0; i <= 4; i++)` zeby obslugiwac kontener attachment-0.

**9. Dodaj `renderFormTab()` — buduje cala zawartosc zakladki Protokol:**

Sekcje formularza (kazda w `<div class="bg-white border rounded p-4 mb-4">`):

- **FORM-01:** "Numer protokolu" — input text z `data-field="form-protocolNumber"`, value z escapeHtml
- **FORM-02:** "Obiekt badany" — 3 inputy: objectName (text), objectAddress (text), objectParcel (text) z `data-field="form-objectName"` itd.
- **FORM-03:** "Wykonawca" — 3 inputy: executorName (text), executorSepE (text), executorSepD (text)
- **FORM-04:** "Warunki badan" — testDate (input type=date), testTemp (input type=number, step=0.1, suffix "°C")
- **FORM-05:** "Przyrządy pomiarowe" — tabela 3-kolumnowa (Wykonane pomiary | Przyrzady pomiarowe | Nr swiadectwa wzorcowania). 4 wiersze — kolumna "Wykonane pomiary" to staly tekst z INSTRUMENT_LABELS[type], kolumna "Przyrzady" to input z `data-field="form-instr-{TYPE}-name"`, kolumna "Nr swiadectwa" to input z `data-field="form-instr-{TYPE}-calibration"`
- **FORM-06 placeholder:** `<div id="assessment-section">` — pusty, wypelniany w Task 2
- **FORM-07 placeholder:** `<div id="orzeczenie-section">` — pusty, wypelniany w Task 2

Uzyj `escapeHtml()` dla KAZDEJ wartosci z AppState renderowanej w innerHTML. Uzyj polskich znakow diakrytycznych (ą, ę, ś, ź, ć, ó, ł, ń, ż) w labelach.

**10. Dodaj `handleFormFieldChange(field, value)` i `handleInstrumentFieldChange(field, value)`:**
- Mapuj data-field na AppState.form pola (patrz research: handleFormFieldChange switch/case)
- Instrument pattern: `form-instr-{TYPE}-{PROP}` z regex match
- testTemp: parsuj do float, puste -> null
- testDate: zapisz string, DODATKOWO wywolaj `updateOrzeczenieDisplay()` (funkcja z Task 2 — jesli nie istnieje, to jest noop bo Task 2 ja doda)

**11. Podepnij event handlery w `bindAppEvents()` lub osobna funkcja `bindFormEvents()`:**
- Listener `input` + `change` na `#attachment-0` (lub delegacja z #app) reagujacy na `[data-field^="form-"]`
- Wywoluje handleFormFieldChange(field, value)

**12. W `init()` — auto-generuj numer protokolu:**
```javascript
AppState.form.protocolNumber = generateProtocolNumber();
```
Wywolaj `renderFormTab()` w init() (analogicznie do renderAttachment1 itd.).

**UWAGA:** Zakladka Protokol jest domyslna (tab 0), wiec attachment-0 musi byc WIDOCZNY a attachment-1 UKRYTY przy starcie. Zaktualizuj poczatkowe klasy w HTML.
  </action>
  <verify>
Otworz index.html w przegladarce:
1. Zakladka "Protokol" jest pierwsza i domyslnie aktywna
2. Widoczne sekcje: numer protokolu (auto-wypelniony RRRR/MM/001), dane obiektu (3 pola), wykonawca (3 pola), warunki badan (data + temperatura), tabela przyrzadow (4 wiersze ze stalymi etykietami)
3. Wpisanie tekstu w pola nie gubi focusu
4. Przelaczenie na Zal. 1 i powrot na Protokol zachowuje wpisane dane
5. Brak bledow w konsoli przegladarki
  </verify>
  <done>
Zakladka "Protokol" (tab 0) wyswietla formularz z polami FORM-01 do FORM-05. Auto-generowany numer protokolu widoczny. Dane zapisuja sie do AppState.form. Przelaczanie zakladek dziala poprawnie (0-4).
  </done>
</task>

<task type="auto">
  <name>Task 2: Ocena koncowa + orzeczenie (FORM-06, FORM-07) z targeted DOM update</name>
  <files>index.html</files>
  <action>
Dodaj automatyczna tabele oceny koncowej i orzeczenie z targeted DOM update.

**1. Dodaj `calcAttachmentVerdict(attachmentKey)` (po calcUZIEMRow):**
Zbiera wszystkie verdykty z danego zalacznika i zwraca 'POZYTYWNY'|'NEGATYWNY'|null.
- attachment1: swzFixedRow.calculated.verdict + wszystkie wiersze z attachment1.rowsBySubsection (iteruj po AppState.sections -> subsections -> rowsBySubsection[sub.id])
- attachment2: attachment2.fixedRow.calculated.verdict + wszystkie wiersze z attachment2.rowsBySubsection
- attachment3: attachment3.rows[].calculated.verdict
- attachment4: attachment4.rows[].calculated.verdict
Logika: jesli allVerdicts.length === 0 return null; jesli wszystkie 'POZYTYWNA' return 'POZYTYWNY'; inaczej 'NEGATYWNY'.

**2. Dodaj `calcFinalAssessment()`:**
```javascript
function calcFinalAssessment() {
  return {
    documentation: 'POZYTYWNY',
    inspection: 'POZYTYWNY',
    swz: calcAttachmentVerdict('attachment1'),
    izol: calcAttachmentVerdict('attachment2'),
    rcd: calcAttachmentVerdict('attachment3'),
    uziem: calcAttachmentVerdict('attachment4')
  };
}
```

**3. Dodaj `calcNextTestDate(testDateStr)`:**
Uzyj parseLocalDate() (z Task 1). Dodaj 5 lat: d.setFullYear(d.getFullYear() + 5). Formatuj: DD.MM.RRRR. Zwroc null jesli brak daty.

**4. Dodaj `calcOrzeczenie()`:**
```javascript
function calcOrzeczenie() {
  const assessment = calcFinalAssessment();
  const allPositive = Object.values(assessment).every(v => v === 'POZYTYWNY');
  const nextDate = calcNextTestDate(AppState.form.testDate);
  return { allPositive, nextDate };
}
```

**5. Wypelnij sekcje FORM-06 w `renderFormTab()`:**
Zamien placeholder `<div id="assessment-section">` na pelna tabele:
- Naglowek: "Ocena wykonanych badan odbiorczych"
- Tabela 3 kolumny: "Wykonane badania odbiorcze" | "Zalaczniki" | "Ogolny wynik"
- 6 wierszy:
  1. "Sprawdzenie dokumentacji instalacji" | "—" | POZYTYWNY (staly, zielony)
  2. "Oględziny instalacji elektrycznej" | "—" | POZYTYWNY (staly, zielony)
  3. "Badanie skutecznosci ochrony przeciwporazeniowej..." | "Zal. 1" | `<td id="assess-swz">`
  4. "Badanie stanu rezystancji izolacji..." | "Zal. 2" | `<td id="assess-izol">`
  5. "Badanie skutecznosci ochrony dodatkowej (RCD)..." | "Zal. 3" | `<td id="assess-rcd">`
  6. "Badanie rezystancji uziemienia..." | "Zal. 4" | `<td id="assess-uziem">`
- Komorki auto-obliczane (id assess-*) inicjalizowane z `calcFinalAssessment()` wartosciami.

**6. Wypelnij sekcje FORM-07 w `renderFormTab()`:**
Zamien placeholder `<div id="orzeczenie-section">` na:
- Naglowek: "Orzeczenie"
- `<p id="orzeczenie-text">` — tekst orzeczenia (POZYTYWNY lub NEGATYWNY, albo "(uzupelnij dane pomiarowe)")
- `<p id="next-test-date">` — "Data nastepnego badania: DD.MM.RRRR r. lub po dokonaniu zmian." (albo "(uzupelnij date badania)")
- Linia podpisu: statyczny tekst "________________  ________________" + "wykonawca     miejscowosc i data"
- Kolor: zielony dla pozytywnego, czerwony dla negatywnego, szary dla braku danych.

**7. Dodaj `updateAssessmentCell(id, verdict)`:**
Targeted DOM update — ustawia textContent i klasy kolorow (text-green-700/text-red-700) na komorce o danym id. Gdy verdict null -> "—" bez koloru.

**8. Dodaj `updateFinalAssessmentDisplay()`:**
Wywoluje calcFinalAssessment(), potem updateAssessmentCell dla kazdej z 4 komorek + updateOrzeczenieDisplay(). Sprawdza czy element istnieje (guard: `if (!document.getElementById('assess-swz')) return;`) — bo moze byc wolana gdy zakladka Protokol nie jest aktywna.

**9. Dodaj `updateOrzeczenieDisplay()`:**
Wywoluje calcOrzeczenie(), aktualizuje textContent i klasy na #orzeczenie-text i #next-test-date. Guard: sprawdz czy elementy istnieja.

**10. Podepnij EventBus subskrypcje (przy istniejacych EventBus.on w sekcji INIT):**
```javascript
EventBus.on('attachment1:changed', updateFinalAssessmentDisplay);
EventBus.on('attachment2:changed', updateFinalAssessmentDisplay);
EventBus.on('attachment3:changed', updateFinalAssessmentDisplay);
EventBus.on('attachment4:changed', updateFinalAssessmentDisplay);
EventBus.on('sections:changed', updateFinalAssessmentDisplay);
```
UWAGA: te subskrypcje MUSZA byc po istniejacych (np. `EventBus.on('attachment1:changed', renderAttachment1)`) — NIE zamiast nich. Dodaj nowe linie.

**11. Przy przelaczeniu na zakladke Protokol (tab 0) — PELNY re-render:**
W bindTabEvents() lub w renderTabs() — gdy UIState.activeTab zmieni sie na 0, wywolaj `renderFormTab()`. To gwarantuje ze tabela oceny jest swiezą (Pitfall 5 z RESEARCH). Pelny re-render jest OK bo przy przelaczaniu zakladek uzytkownik nie ma aktywnego focusu w polach formularza.

UWAGA: EventBus callbacks `updateFinalAssessmentDisplay()` uzywaja targeted update (NIE pelny re-render) — guard sprawdza czy elementy DOM istnieja (jesli tab nie jest aktywny, elementy nie istnieja i update jest pomijany). To zapobiega zbednym re-renderom.
  </action>
  <verify>
Otworz index.html w przegladarce:
1. Zakladka Protokol pokazuje tabele "Ocena wykonanych badan" z 6 wierszami — 2 stale POZYTYWNY, 4 auto "—"
2. Sekcja "Orzeczenie" widoczna z tekstem "(uzupelnij dane pomiarowe)" i "(uzupelnij date badania)"
3. Przejdz do Zal. 1, wpisz Zs=0.5 i Usk=230 w wierszu — ocena POZYTYWNA pojawi sie
4. Wroc na zakladke Protokol — komorka "Badanie SWZ" pokazuje POZYTYWNY (zielony)
5. Wpisz date badania np. 2026-02-20 — orzeczenie wyswietla "Data nastepnego badania: 20.02.2031r."
6. Zmien verdict jednego wiersza na NEGATYWNA — orzeczenie zmienia sie na negatywne (czerwone)
7. Brak bledow w konsoli przegladarki
  </verify>
  <done>
Tabela oceny koncowej (FORM-06) generuje sie automatycznie z wynikami per zalacznik. Orzeczenie (FORM-07) wyswietla prawidlowy tekst z data nastepnego badania (+5 lat). EventBus aktualizuje ocene przy kazdej zmianie danych w zalacznikach. Targeted DOM update nie gubi focusu w polach formularza.
  </done>
</task>

</tasks>

<verification>
**Weryfikacja calosciowa po obu taskach:**

1. `grep -c "AppState.form" index.html` — powinno zwrocic >= 5 (form w state + odczyty w renderze + zapisy w handlerze)
2. `grep -c "escapeHtml" index.html` — powinno zwrocic >= 8 (kazde pole renderowane w innerHTML)
3. `grep -c "calcFinalAssessment\|calcAttachmentVerdict\|calcOrzeczenie\|calcNextTestDate" index.html` — powinno zwrocic >= 4 (definicje + wywolania)
4. `grep -c "updateFinalAssessmentDisplay\|updateOrzeczenieDisplay\|updateAssessmentCell" index.html` — powinno zwrocic >= 6
5. `grep "data-tab=\"0\"" index.html` — zakladka Protokol istnieje
6. `grep "attachment-0" index.html` — kontener zakladki istnieje
7. `grep "INSTRUMENT_LABELS" index.html` — stale etykiety istnieja
8. `grep "parseLocalDate" index.html` — timezone-safe date parsing istnieje

**Manualna weryfikacja w przegladarce:**
- Otworz index.html — zakladka Protokol domyslnie aktywna
- Wypelnij numer protokolu, dane obiektu, wykonawcy, date, temperature, przyrządy — dane zachowane po przelaczeniu zakladek
- Przejdz do Zal. 1-4, wpisz dane pomiarowe — wroc na Protokol — ocena odzwierciedla wyniki
- Zmien date badania — data nastepnego badania aktualizuje sie (+5 lat)
</verification>

<success_criteria>
- Zakladka "Protokol" widoczna jako tab 0, domyslnie aktywna
- FORM-01: Numer protokolu auto-generowany (RRRR/MM/001), edytowalny
- FORM-02: 3 pola danych obiektu (nazwa, adres, dzialka) z zapisem do AppState
- FORM-03: 3 pola wykonawcy (imie, SEP E, SEP D) z zapisem do AppState
- FORM-04: Data badania (input date) + temperatura (input number) z zapisem
- FORM-05: Tabela 4 wierszy przyrzadow ze stalymi etykietami i edytowalnymi polami
- FORM-06: Tabela oceny 6 wierszy — 2 stale POZYTYWNY + 4 auto z attachment1-4
- FORM-07: Orzeczenie z data nastepnego badania (+5 lat) i poprawnym kolorem
- Brak gubienia focusu przy wpisywaniu danych w formularzu
- Brak bledow w konsoli przegladarki
</success_criteria>

<output>
After completion, create `.planning/phases/02-kompletnosc-normowa/02-01-SUMMARY.md`
</output>
